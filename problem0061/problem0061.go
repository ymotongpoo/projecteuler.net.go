// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
//
// Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
// Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
// Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
// Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
// Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
// Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
//
// The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
// Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
// This is the only set of 4-digit numbers with this property.
// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
package main

func triangle(n int) int {
	return (n*n + n) / 2
}

func square(n int) int {
	return n * n
}

func pentagonal(n int) int {
	return (3*n*n - n) / 2
}

func hexagonal(n int) int {
	return 2*n*n - n
}

func heptagonal(n int) int {
	return (5*n*n - 3*n) / 2
}

func octagonal(n int) int {
	return 3*n*n - 2*n
}

// findFourDigits lists up all four digits polygonal numbers.
func findFourDigits(f func(int) int) []int {
	ret := []int{}
	i := 0
	for {
		n := f(i)
		if n < 1000 {
			i++
			continue
		} else if n >= 10000 {
			return ret
		}
		ret = append(ret, n)
		i++
	}
}

// Candidate is cyclic polygonal candidate.
type Candidate struct {
	p int // polygonal number
	i int // index
}

// next finds cyclic polygonal candidates of c from polygonals.
func next(c Candidate, polygonals [][]int) []Candidate {
	ret := []Candidate{}
	for i := range polygonals {
		if i == c.i {
			continue
		}
		for _, n := range polygonals[i] {
			if c.p%100 == n/100 {
				ret = append(ret, Candidate{p: n, i: i})
			}
		}
	}
	return ret
}

func main() {
	polygonals := make([][]int, 6)
	for i := range polygonals {
		polygonals[i] = []int{}
	}

	polygonals[0] = findFourDigits(triangle)
	polygonals[1] = findFourDigits(square)
	polygonals[2] = findFourDigits(pentagonal)
	polygonals[3] = findFourDigits(hexagonal)
	polygonals[4] = findFourDigits(heptagonal)
	polygonals[5] = findFourDigits(octagonal)

	// TODO(ymotongpoo): implement cyclic number detection algorithm.
	// Came up with implementation using channel and recursion.
	for _, p := range polygonals[0] {
		cs := next(Candidate{p, 0}, polygonals)
		_ = cs
	}
}
