// Distinct powers
//
// Consider all integer combinations of a^b for 2 <= a <= 5 and 2 <= b <= 5:
//
// 2^2=4, 2^3=8, 2^4=16, 2^5=32
// 3^2=9, 3^3=27, 3^4=81, 3^5=243
// 4^2=16, 4^3=64, 4^4=256, 4^5=1024
// 5^2=25, 5^3=125, 5^4=625, 5^5=3125
// If they are then placed in numerical order, with any repeats removed,
// we get the following sequence of 15 distinct terms:
//
// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
//
// How many distinct terms are in the sequence generated by
// a^b for 2 <= a <= 100 and 2 <= b <= 100?
package main

import (
	"fmt"
	"strings"
)

type Factor struct {
	Base  int
	Power int
}

var DistinctTerms = map[string]struct{}{}

func Generator(c chan int) {
	for i := 2; ; i++ {
		c <- i
	}
}

func Filter(in <-chan int, out chan<- int, prime int) {
	for {
		n := <-in
		if n%prime != 0 {
			out <- n
		}
	}
}

func PrimesBelow(n int) []int {
	in := make(chan int)
	go Generator(in)
	primes := []int{}
	for {
		prime := <-in
		if prime > n {
			break
		}
		primes = append(primes, prime)
		out := make(chan int)
		go Filter(in, out, prime)
		in = out
	}
	return primes
}

func Stringfy(primes []int, a, b int) string {
	factors := []*Factor{}
	// find all factors and its power
	for _, p := range primes {
		count := 0
		if p > a {
			break
		}
		for p <= a {
			if a%p != 0 {
				break
			}
			a /= p
			count++
		}
		if count != 0 {
			factors = append(factors, &Factor{p, count})
		}
	}
	// stringfy all factors
	factorStr := make([]string, len(factors))
	for i, f := range factors {
		factorStr[i] = fmt.Sprintf("%v^%v", f.Base, f.Power*b)
	}
	return strings.Join(factorStr, "*")
}

func Solver() {
	primes := PrimesBelow(100)
	for a := 2; a <= 100; a++ {
		for b := 2; b <= 100; b++ {
			s := Stringfy(primes, a, b)
			if _, ok := DistinctTerms[s]; !ok {
				DistinctTerms[s] = struct{}{}
			}
		}
	}
	fmt.Println(len(DistinctTerms))
}

func main() {
	Solver()
}
